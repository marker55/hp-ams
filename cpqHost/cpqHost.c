/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <sys/stat.h>
#include <sys/types.h>

#include <malloc.h>
#include <string.h>
#include <dirent.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* NOTE: fix this include later.... */
#include <sys/statvfs.h>

#include "libcpqhost/cpqhost.h"
#include "cpqHost.h"
#include "amsHelper.h"

extern  int InitLibCpqHost(void);
extern void init_cpqHoFileSysTable(void);
extern void init_cpqHoSwVer(void);
extern void init_cpqHostOsMem(void);
extern void initialize_table_cpqHoSWRunningTable(void);
extern void init_cpqHoSwVerTable(void);
extern void init_cpqHoSWRunningTable(void);
extern int header_generic(struct variable *, oid *, size_t *, int, size_t *,
                   WriteMethod **);


extern char *GenericData;
extern char *GenericDataStr;
extern char *GenericDataEnv;
extern int testtrap_interval;
distro_id_t *myDistro = NULL;
#ifndef HELPER_VERSION
#define HELPER_VERSION "0.0.0"
#endif

/* this is information for cpqHost MIB */
#define CPQMIB         11
#define CPQMIBREVMAJOR 1
#define CPQMIBREVMINOR 36

extern unsigned char cpqHoMibHealthStatusArray[];

/*
 * cpqHostOs_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             cpqHostOs_variables_oid[] = { 1, 3, 6, 1, 4, 1, 232, 11 };
oid             cpqHostMib_oid[] = { 1, 3, 6, 1, 4, 1, 232, 11, 1 };
oid             cpqHostInfo_oid[] = { 1, 3, 6, 1, 4, 1, 232, 11, 2, 2 };
oid             sysDescr_oid[] = { 1, 3, 6, 1, 2, 1, 1, 1 };

void SendcpqHostGenericTrap();
/*
 * variable4 cpqHostOs_variables:
 *   this variable defines function callbacks and type return information 
 *   for the cpqHostOs mib section 
 */

#define CPQHOSTMIBREVMAJOR		1
#define CPQHOSTMIBREVMINOR		2
#define CPQHOSTMIBCONDITION		3

#define CPQHOSTNAME		        1
#define CPQHOSTVERSION		        2
#define CPQHOSTDESC		        3
#define CPQHOSTOSTYPE		        4
#define CPQHOSTTELNET		        5
#define CPQHOSTSYSTEMROLE		6
#define CPQHOSTSYSTEMROLEDETAIL		7
#define CPQHOSTDUMPSTATE                 8
#define CPQHOSTDUMPCONDITION             9
#define CPQHOSTDUMPMONITORING            10
#define CPQHOSTLOGICALCPUSUPPORTED       11
#define CPQHOSTSYSTEMNAME		12
#define CPQHOSTSYSDESCR 		13

#define CPQHO_FILESYS_CONDITION		1
#define CPQHO_SWRUNNINGTRAPDESC		2
#define CPQHO_SWVERAGENTSVER		3
#define CPQHO_GENERICDATA		4
#define CPQHO_MIBSTATUSARRAY		5
#define CPQHO_MIBHEALTHSTATUSARRAY	6
#define CPQHO_TRAPFLAGS		        7

struct variable7 cpqHostOs_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */

    {CPQHO_FILESYS_CONDITION, ASN_INTEGER, RONLY,
         var_cpqHostOs, 3, {2, 4, 2}},

    {CPQHO_SWRUNNINGTRAPDESC, ASN_OCTET_STR, RONLY,
         var_cpqHostOs, 3, {2, 6, 2}},

    {CPQHO_SWVERAGENTSVER, ASN_OCTET_STR, RONLY,
         var_cpqHostOs, 3, {2, 7, 3}},

    {CPQHO_GENERICDATA, ASN_OCTET_STR, RWRITE,
         var_cpqHostOs, 3, {2, 8, 1}},

    {CPQHO_MIBSTATUSARRAY, ASN_OCTET_STR, RONLY,
         var_cpqHostOs, 3, {2, 10, 1}},

    {CPQHO_MIBHEALTHSTATUSARRAY, ASN_OCTET_STR, RONLY,
         var_cpqHostOs, 3, {2, 10, 7}},

    {CPQHO_TRAPFLAGS, ASN_INTEGER, RONLY,
         var_cpqHostOs, 3, {2, 11, 1}},
};

#ifdef DEFERRED
#define CPQHOFWVER_INDEX		1
#define CPQHOFWVER_CATEGORY		2
#define CPQHOFWVER_DEVICETYPE		3
#define CPQHOFWVER_DISPLAYNAME		4
#define CPQHOFWVER_VERSION		5
#define CPQHOFWVER_LOCATION		6
#define CPQHOFWVER_XMLSTRING		7
#define CPQHOFWVER_KEYSTRING		8
#define CPQHOFWVER_UPDATEMETHOD		9
struct variable7 cpqHoFwVer_variables[] = {
    {CPQHOFWVER_INDEX, ASN_INTEGER, RONLY,
         var_cpqHoFwVerTable, 5, {2, 14, 1, 1, 1}},
    {CPQHOFWVER_CATEGORY, ASN_INTEGER, RONLY,
         var_cpqHoFwVerTable, 5, {2, 14, 1, 1, 2}},
    {CPQHOFWVER_DEVICETYPE, ASN_INTEGER, RONLY,
         var_cpqHoFwVerTable, 5, {2, 14, 1, 1, 3}},
    {CPQHOFWVER_DISPLAYNAME, ASN_OCTET_STR, RONLY,
         var_cpqHoFwVerTable, 5, {2, 14, 1, 1, 4}},
    {CPQHOFWVER_VERSION, ASN_OCTET_STR, RONLY,
         var_cpqHoFwVerTable, 5, {2, 14, 1, 1, 5}},
    {CPQHOFWVER_LOCATION, ASN_OCTET_STR, RONLY,
         var_cpqHoFwVerTable, 5, {2, 14, 1, 1, 6}},
    {CPQHOFWVER_XMLSTRING, ASN_OCTET_STR, RONLY,
         var_cpqHoFwVerTable, 5, {2, 14, 1, 1, 7}},
    {CPQHOFWVER_KEYSTRING, ASN_OCTET_STR, RONLY,
         var_cpqHoFwVerTable, 5, {2, 14, 1, 1, 8}},
    {CPQHOFWVER_UPDATEMETHOD, ASN_INTEGER, RONLY,
         var_cpqHoFwVerTable, 5, {2, 14, 1, 1, 9}},
};
#endif

/*
 * (L = length of the oidsuffix) 
 */


/** Initializes the cpqHost module */
void
init_cpqHost(void)
{

    DEBUGMSGTL(("cpqHost", "Initializing\n"));

    myDistro = getDistroInfo();

    cpqHostMibStatusArray[CPQMIB].major = CPQMIBREVMAJOR;
    cpqHostMibStatusArray[CPQMIB].minor = CPQMIBREVMINOR;

    netsnmp_register_scalar_group(
        netsnmp_create_handler_registration("cpqHostMib", 
                                            cpqHostMib_handler,
                                            cpqHostMib_oid, 
                                            OID_LENGTH(cpqHostMib_oid),
                                            HANDLER_CAN_RONLY),
        CPQHOSTMIBREVMAJOR, CPQHOSTMIBCONDITION);

    netsnmp_register_scalar_group(
        netsnmp_create_handler_registration("cpqHostInfo", 
                                            cpqHostInfo_handler,
                                            cpqHostInfo_oid, 
                                            OID_LENGTH(cpqHostInfo_oid),
                                            HANDLER_CAN_RONLY),
        CPQHOSTNAME, CPQHOSTSYSDESCR);

    init_cpqHoFileSysTable();
    init_cpqHoSwVerTable();
    init_cpqHostOsMem();
    init_cpqHoSWRunningTable();

    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB("cpqHostOs", cpqHostOs_variables, variable7,
                 cpqHostOs_variables_oid);

    /*
     * place any other initialization junk you need here 
     */

    cpqHostMibStatusArray[CPQMIB].stat = MIB_STATUS_AVAILABLE;
    cpqHostMibStatusArray[CPQMIB].cond = MIB_CONDITION_OK;

    DEBUGMSGTL(("cpqHost", "Checkinging periodic test trap interval = %d\n", testtrap_interval));
    if (testtrap_interval >= 0)  {
        if ((GenericDataStr = getenv(GenericDataEnv)) != (char *) 0)
            GenericData = GenericDataStr;
        DEBUGMSGTL(("cpqHost", "Registering periodic test trap alarm\n"));
        SendcpqHostGenericTrap();
        if (testtrap_interval > 0) {
        if (snmp_alarm_register(testtrap_interval, 
                             SA_REPEAT, 
                             (SNMPAlarmCallback *) &SendcpqHostGenericTrap, 
                             NULL) == 0 )
            DEBUGMSGTL(("cpqHost", "Alarm register failed\n"));
        } 
    }
}

int
cpqHostMib_handler(netsnmp_mib_handler          *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info   *reqinfo,
               netsnmp_request_info         *requests)
{
    long val = 0;

    switch (reqinfo->mode) {
    case MODE_GET:
        switch (requests->requestvb->name[ reginfo->rootoid_len - 2 ]) {
            case CPQHOSTMIBREVMAJOR:
                val = CPQMIBREVMAJOR;
                break;
            case CPQHOSTMIBREVMINOR:
                val = CPQMIBREVMINOR;
                break;
            case CPQHOSTMIBCONDITION:
                val = 2; /* MIB_STATUS_OK */
                break;
            default:
                /*
                * An unsupported/unreadable column (if applicable)
                */
                snmp_log(LOG_ERR, "unknown object (%lu) in cpqHostMib_handler\n",
                     requests->requestvb->name[ reginfo->rootoid_len - 2 ]);
                netsnmp_set_request_error( reqinfo, requests,
                                            SNMP_NOSUCHOBJECT );
                return SNMP_ERR_NOERROR;
        }
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&val, sizeof(val));
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in cpqHostMib_handlery\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;

}

int
cpqHostInfo_handler(netsnmp_mib_handler          *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info   *reqinfo,
               netsnmp_request_info         *requests)
{
    static unsigned char string[SPRINT_MAX_LEN];

    DEBUGMSGTL(("cpqHostInfo", "Handler\n"));

    switch (reqinfo->mode) {
    case MODE_GET:
        switch (requests->requestvb->name[ reginfo->rootoid_len - 2 ]) {
            case CPQHOSTNAME:
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                   (u_char *) myDistro->Description,
                                    strlen((char *)myDistro->Description) );
                break;
            case CPQHOSTVERSION:
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                   (u_char *) myDistro->VersionString,
                                    strlen((char *)myDistro->VersionString) );
                break;
            case CPQHOSTDESC:
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                   (u_char *) myDistro->LongDistro,
                                    strlen((char *)myDistro->LongDistro) );
                break;
            case CPQHOSTOSTYPE:
                snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                           myDistro->cpqHostOsType);
                break;
            case CPQHOSTTELNET:
                snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER,
                                           TELNET_NOTAVAILABLE);
                break;
            case CPQHOSTSYSTEMROLE:
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                   (u_char *) myDistro->Role,
                                    strlen((char *)myDistro->Role) );
                break;
            case CPQHOSTSYSTEMROLEDETAIL:
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                   (u_char *) myDistro->Role,
                                    strlen((char *)myDistro->Role) );
                break;
            case CPQHOSTSYSTEMNAME:
                gethostname((char *)string,SPRINT_MAX_LEN);
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                   (u_char *) string,
                                    strlen((char *)string) );
                break;
            case CPQHOSTSYSDESCR:
                snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                   (u_char *) myDistro->sysDescr,
                                    strlen((char *)myDistro->sysDescr) );
                break;

            default:
                netsnmp_set_request_error( reqinfo, requests,
                                            SNMP_NOSUCHOBJECT );
                return SNMP_ERR_NOERROR;
        }
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in cpqHostMib_handlery\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;

}

/*
 * var_cpqHostOs():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_cpqHostOs(struct variable *vp,
              oid * name,
              size_t *length,
              int exact, size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static char string[SPRINT_MAX_LEN];
    int j;

    DEBUGMSGTL(("cpqHostOS", "Handler\n"));

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;
    /* prevent struct from changing while we are working with it */

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case CPQHO_FILESYS_CONDITION:
        long_ret = MIB_STATE_OK;
        return (unsigned char *) &long_ret;

    case CPQHO_SWVERAGENTSVER:
        strcpy(string, HELPER_VERSION);
        *var_len = strlen(string);
        return (unsigned char *) string;

    case CPQHO_GENERICDATA:
        strncpy(string, GenericData, sizeof(string) - 1);
        *var_len = strlen(string) + 1;
        return (unsigned char *) string;

    case CPQHO_MIBSTATUSARRAY:
        memcpy(string, &cpqHostMibStatusArray[0],20*sizeof(MibStatusEntry));
        *var_len = 20*sizeof(MibStatusEntry);
        return (unsigned char *) string;

    case CPQHO_MIBHEALTHSTATUSARRAY:
	for (j =  CPQHO_MIBHEALTHSTATUSARRAY_LEN - 1; 
	     (j >= 0) && (cpqHoMibHealthStatusArray[j] == 0);
	     j--) {}
	j++;
	if (j > 0) 
		memcpy(string, cpqHoMibHealthStatusArray, j);
        *var_len = j;
        return (unsigned char *) string;

    default:
        ERROR_MSG("");
    }
    return NULL;
}

void SendcpqHostGenericTrap()
{
    static oid compaq[] = { 1, 3, 6, 1, 4, 1, 232 };
    static oid compaq_len = 7;
    static oid sysName[] = { 1, 3, 6, 1, 2, 1, 1, 5, 0 };
    static oid cpqHoTrapFlags[] = { 1, 3, 6, 1, 4, 1, 232, 11, 2, 11, 1, 0 };
    static oid cpqHoGenericData[] = { 1, 3, 6, 1, 4, 1, 232, 11, 2, 8, 1, 0 };
    static oid cpqHoMibHealthStatus[] = { 1, 3, 6, 1, 4, 1, 232, 11, 2, 10, 7, 0};
    static oid cpqHostMibStatus[] = { 1, 3, 6, 1, 4, 1, 232, 11, 2, 10, 1, 0};

    netsnmp_variable_list *var_list = NULL;
    struct utsname sys_name;
    unsigned int cpqHoTrapFlag;

    DEBUGMSGTL(("cpqHost", "Sending periodic test trap\n"));

    uname(&sys_name);   /* get sysName */

    snmp_varlist_add_variable(&var_list, sysName,
            sizeof(sysName) / sizeof(oid),
            ASN_OCTET_STR,
            (u_char *) sys_name.nodename,
            strlen(sys_name.nodename));

    snmp_varlist_add_variable(&var_list, cpqHoTrapFlags,
            sizeof(cpqHoTrapFlags) / sizeof(oid),
            ASN_INTEGER, &cpqHoTrapFlag,
            sizeof(cpqHoTrapFlag));

    snmp_varlist_add_variable(&var_list, cpqHoGenericData,
            sizeof(cpqHoGenericData) / sizeof(oid),
            ASN_OCTET_STR, (u_char *) GenericData,
            strlen(GenericData));

    snmp_varlist_add_variable(&var_list, cpqHoMibHealthStatus,
            sizeof(cpqHoMibHealthStatus) / sizeof(oid),
            ASN_OCTET_STR, (u_char *) cpqHoMibHealthStatusArray,
            64);

    snmp_varlist_add_variable(&var_list, cpqHostMibStatus,
            sizeof(cpqHostMibStatus) / sizeof(oid),
            ASN_OCTET_STR, (u_char *) cpqHostMibStatusArray,
            20*sizeof(MibStatusEntry));

    send_enterprise_trap_vars(SNMP_TRAP_ENTERPRISESPECIFIC,
                    11003,
                    compaq,
                    compaq_len,
                    var_list);

    DEBUGMSGTL(("cpqhost:", "Free varbind list...\n"));
    snmp_free_varbind(var_list);
    DEBUGMSGTL(("cpqhost:", "Done freeing varbind list...\n"));

}
